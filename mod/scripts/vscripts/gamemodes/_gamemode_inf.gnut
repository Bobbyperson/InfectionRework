untyped

global function GamemodeInfection_Init
global function TestEvac
global function NoInfect
global function setTime
const int EVAC_SHIP_HEALTH = 50000
const int EVAC_SHIP_SHIELDS = 5000

const array<string> EVAC_EMBARK_ANIMS_3P = [
	"pt_e3_rescue_side_embark_A",
	"pt_e3_rescue_side_embark_B",
	"pt_e3_rescue_side_embark_C",
	"pt_e3_rescue_side_embark_D",
	"pt_e3_rescue_side_embark_E",
	"pt_e3_rescue_side_embark_F",
	"pt_e3_rescue_side_embark_G",
	"pt_e3_rescue_side_embark_H"
]

const array<string> EVAC_IDLE_ANIMS_1P = [
	"ptpov_e3_rescue_side_embark_A_idle",
	"ptpov_e3_rescue_side_embark_B_idle",
	"ptpov_e3_rescue_side_embark_C_idle",
	"ptpov_e3_rescue_side_embark_D_idle",
	"ptpov_e3_rescue_side_embark_E_idle",
	"ptpov_e3_rescue_side_embark_F_idle",
	"ptpov_e3_rescue_side_embark_G_idle",
	"ptpov_e3_rescue_side_embark_H_idle"
]

const array<string> EVAC_IDLE_ANIMS_3P = [
	"pt_e3_rescue_side_idle_A",
	"pt_e3_rescue_side_idle_B",
	"pt_e3_rescue_side_idle_C",
	"pt_e3_rescue_side_idle_D",
	"pt_e3_rescue_side_idle_E",
	"pt_e3_rescue_side_idle_F",
	"pt_e3_rescue_side_idle_G",
	"pt_e3_rescue_side_idle_H"
]

struct {
	bool hasHadFirstInfection = false
	bool hasHadLastInfection = false
	bool hasResetTimer = false
	bool evacCame = false
	bool evacDead = false
	array<entity> playersToNotifyOfInfection
	
	// evac stuff
	array<entity> evacNodes
	table<entity, int> killstreak
	table<entity, int> deathstreak
	table<entity, bool> hardmode
	table<entity, bool> moved
	entity spaceNode
	entity currentEvacNode
	entity evacDropship
	entity evacIcon

	array<string> lowburnreward = [ "burnmeter_ticks", 
									"burnmeter_radar_jammer", 
									"burnmeter_at_turret_weapon",
									"burnmeter_arc_trap",
									"burnmeter_phase_rewind"]

	array<string> medburnreward = [ "burnmeter_ap_turret_weapon",
									"burnmeter_amped_weapons",
									"burnmeter_maphack",
									"burnmeter_ticks", 
									"burnmeter_radar_jammer", 
									"burnmeter_at_turret_weapon",
									"burnmeter_arc_trap",
									"burnmeter_phase_rewind"]

	array<string> highburnreward = ["burnmeter_ap_turret_weapon",
									"burnmeter_amped_weapons",
									"burnmeter_maphack",
									"burnmeter_ticks", 
									"burnmeter_radar_jammer", 
									"burnmeter_at_turret_weapon",
									"burnmeter_smart_pistol",
									"burnmeter_phase_rewind",
									"burnmeter_arc_trap"] // i could probably just append these to each other but why append it on each intiation when i could just do this
} file


// nessie fix
struct EvacShipSetting
{
	asset shipModel
	string flyinSound
	string hoverSound
	string flyoutSound
}

void function GamemodeInfection_Init()
{
	PrecacheParticleSystem( FX_EVAC_MARKER )
	
	SetLoadoutGracePeriodEnabled( true ) // prevent modifying loadouts with grace period
	SetWeaponDropsEnabled( false ) // executions bypass this, now a feature. DO NOT FIX
	SetShouldUseRoundWinningKillReplay( true )
	Riff_ForceTitanAvailability( eTitanAvailability.Never )
	Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
	ClassicMP_ForceDisableEpilogue( true )
	ClassicMP_SetCustomIntro( InfectionNoIntroSetup, Infection_NoIntro_GetLength() )
	// ClassicMP_SetCustomIntro( ClassicMP_DefaultNoIntro_Setup, ClassicMP_DefaultNoIntro_GetLength() )

	SetShouldPlayerStartBleedoutFunc( InfectionShouldPlayerStartBleedout )
	AddCallback_OnClientConnected( InfectionInitPlayer )
	AddCallback_OnPlayerKilled( InfectionOnPlayerKilled )
	AddCallback_OnPlayerRespawned( RespawnInfected )
	AddCallback_GameStateEnter( eGameState.Playing, SelectFirstInfected )
	AddCallback_GameStateEnter( eGameState.Playing, Playing)
	AddCallback_OnReceivedSayTextMessage( HardmodeChat )

	SetTimeoutWinnerDecisionFunc( TimeoutCheckSurvivors ) 

	AddCallback_GameStateEnter( eGameState.WinnerDetermined, OnWinnerDetermined )

	RegisterSignal( "ResetEvac" )
	RegisterSignal( "BoostRefunded" ) // for arc trap to work

	string mapname = GetMapName()
	if (mapname != "mp_wargames"){
		SetSpawnpointGamemodeOverride( FFA )
	}
	switch(mapname)
	{
		case "mp_angel_city":
			file.evacNodes.append( CreateScriptRef( < 2527.889893, -2865.360107, 753.002991 >, < 0, -80.54, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 1253.530029, -554.075012, 811.125 >, < 0, 180, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 2446.989990, 809.364014, 576.0 >, < 0, 90.253, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < -2027.430054, 960.395020, 609.007996 >, < 0, 179.604, 0 > ) )
			file.spaceNode = CreateScriptRef( < -1700, -5500, -7600 >, < -3.620642, 270.307129, 0 > )
		break

		case "mp_colony02":
			file.evacNodes.append( CreateScriptRef( < -475.129913, 1480.167847, 527.363953 >, < 8.841560, 219.338501, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 1009.315186, 3999.888916, 589.914917 >, < 23.945116, -146.680725, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 2282.868896, -1363.706543, 846.188660 >, < 23.945116, -146.680725, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 1911.771606, -752.053101, 664.741821 >, < 9.955260, 138.721191, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < 1985.563232, -1205.455078, 677.444763 >, < 13.809734, -239.877441, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < -59.625496, -1858.108887, 811.592407 >, < 20.556290, -252.775146, 0 > ) )
			file.evacNodes.append( CreateScriptRef( < -1035.991211, -671.114380, 824.180908 >, < 16.220453, -24.511070, 0 > ) )
			file.spaceNode = CreateScriptRef( < -1700, -5500, -7600 >, < -3.620642, 270.307129, 0 > )
		break

		case "mp_wargames":
			file.evacNodes.append( CreateScriptRef( < -1254.61, 3538.7, 279.014 >, < 0, 90.6091, 0 >))
			file.spaceNode = CreateScriptRef( < -1700, -5500, -7600 >, < -3.620642, 270.307129, 0 > )
		break
		
		case "mp_lf_stacks":
			file.evacNodes.append( CreateScriptRef( < 294.715, 2164.05, 360.226 >, < 0, -90.66, 0 > ) )
			file.spaceNode = ( CreateScriptRef( < -1583.54, 2065.05, 1447.59 >, < 0, -152.03, 0 > ) )
		break
		
		case "mp_lf_deck":
			file.evacNodes.append( CreateScriptRef( < 261.644, -1836.96, 458.099 >, < 0, 89.4534, 0 > ) )
			file.spaceNode = ( CreateScriptRef( < -3546.1, -3402.22, 2210.24 >, < 0, -11.7048, 0 > ) )
		break
		
		case "mp_lf_meadow":
			file.evacNodes.append( CreateScriptRef( < 128.004, -1598.94, 456.993 >, < 0, 89.8562, 0 > ) )
			file.spaceNode = ( CreateScriptRef( < 2501.73, -1671.72, 1436.55 >, < 0, 26.0562, 0 > ) )
		break

		case "mp_lf_traffic":
			file.evacNodes.append( CreateScriptRef( < 354.044, -1735.66, 218.531 >, < 0, 89.1288, 0 > ) )
			file.spaceNode = ( CreateScriptRef( < 4998.45, 110.398, -6136.04 >, < 0, 179.053, 0 > ) )
		break

		case "mp_lf_township":
			file.evacNodes.append( CreateScriptRef( < 1299.63, 130.964, 375.644 >, < 0, -178.711, 0 > ) )
			file.spaceNode = (CreateScriptRef( < 4998.45, 110.398, -6136.04 >, < 0, 179.053, 0 > ) )
		break

		case "mp_lf_uma":
			file.evacNodes.append(CreateScriptRef( < 994.444, 359.271, 218.583 >, < 0, -177.181, 0 > ) )
			file.spaceNode = (CreateScriptRef( < 4998.45, 110.398, -6136.04 >, < 0, 168.053, 0 > ) )
		break

		case "mp_coliseum":
			file.evacNodes.append(CreateScriptRef( < -3.50534, -4.30921, 126.576 >, < 0, 173.968, 0 > ) )
			file.spaceNode = (CreateScriptRef( < 2988.35, 1367.398, 1354.04 >, < 0, 158.053, 0 > ) )
		break

		case "mp_coliseum_column":
			file.evacNodes.append(CreateScriptRef( < -3.50534, -4.30921, 126.576 >, < 0, 173.968, 0 > ) )
			file.spaceNode = (CreateScriptRef( < 2988.35, 1367.398, 1354.04 >, < 0, 158.053, 0 > ) )
		break
		
		default:
		break
	}

	RegisterWeaponDamageSource( "funnyboomer", "Boomer Explosion" )
	AddCallback_OnClientDisconnected( InfectionOnPlayerDisconnected )
}

void function Playing(){
	AddCallback_OnClientConnected( AddPlayerCallbacks )
	AddCallback_OnClientDisconnected( DeletePlayerRecords )
	AddCallback_OnPlayerRespawned( Moved )

	foreach (entity player in GetPlayerArray()){
		AddPlayerCallbacks( player )
		file.moved[ player ] <- false
	}
}

void function DeletePlayerRecords( entity player ){
	if (player in file.moved){
		delete file.moved[ player ]
	}
}

void function AddPlayerCallbacks( entity player ){
	file.moved[player] <- false
	AddPlayerPressedForwardCallback( player, bMoved )
	AddPlayerPressedBackCallback( player, bMoved )
	AddPlayerPressedLeftCallback( player, bMoved )
	AddPlayerPressedRightCallback( player, bMoved )
}

void function Moved( entity player ){
	file.moved[ player ] <- true
}

bool function bMoved( entity player ){
	Moved( player )
	return true
}

void function InfectionInitPlayer( entity player )
{
	if ( GetGameState() >= eGameState.Playing )
		InfectPlayer( player, player )
	file.killstreak[player] <- 0
	file.deathstreak[player] <- 0
	file.hardmode[player] <- false
}

void function InfectionOnPlayerDisconnected( entity player )
{
	thread InfectionOnPlayerDisconnectedDelayed(player)
}

// gotta start documenting code even more since this file is getting bigger and bigger each time
void function InfectionOnPlayerDisconnectedDelayed( entity player ) // 7 august 2023
{
	// how many infected are in the game currently
	if ( !file.hasHadFirstInfection ) {
		return
	}
	WaitFrame()
	int infectedCount = GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED ).len()
	if ( infectedCount == 0 )
	{
		// find a random poor soul lmao
		array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
		if ( survivors.len() > 0 )
		{
			int selected = RandomInt( survivors.len() )
			entity infected = survivors[ selected ]

			// give a 5 seconds heads up to the selected player and everyone else
			foreach ( entity player in GetPlayerArray() )
				if ( player != infected )
					NSSendAnnouncementMessageToPlayer( player, "NEW HOST FOUND", "A random survivor will be infected in 5 seconds!", <0,1,0>, 1, 0 ) // rgb, should be green
				else
					NSSendAnnouncementMessageToPlayer( player, "YOU HAVE BECOME INFECTED", "You will become infected in 5 seconds!", <0,1,0>, 1, 1 )

			HolsterViewModelAndDisableWeapons( infected )
			wait 5.0
			if ( !IsValid(infected) )
				return
			InfectPlayer( infected, infected )
			RespawnInfected( infected )
			DeployViewModelAndEnableWeapons( infected )

			// if ( !file.hasResetTimer && !file.evacCame ) // reset timer if it hasn't been reset yet
			// {
			// 	file.hasResetTimer = true
			// 	setTime( 360.0 ) // should be 5 minutes
			// }
		}
	}
}

void function InfectionInitSpawnPlayer( entity player )
{
	if ( GetGameState() != eGameState.Prematch )
		return

	if ( IsPrivateMatchSpectator( player ) ) // private match spectators use custom spawn logic
	{
		RespawnPrivateMatchSpectator( player )
		return
	}

	if ( IsAlive( player ) )
		player.Die()

	SetTeam( player, INFECTION_TEAM_SURVIVOR )
	player.RespawnPlayer( FindSpawnPoint( player, false, false ) )

	player.FreezeControlsOnServer()
	AddCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING )
	ScreenFadeFromBlack( player, 0.5, 0.5 )
}

float function Infection_NoIntro_GetLength()
{
	return 10.0
}

void function InfectionNoIntroStart()
{
	ClassicMP_OnIntroStarted()

	foreach ( entity player in GetPlayerArray() )
		InfectionInitSpawnPlayer( player )
		
	wait 10.0
		
	foreach ( entity player in GetPlayerArray() )
	{
		if ( !IsPrivateMatchSpectator( player ) )
		{
			player.UnfreezeControlsOnServer()
			RemoveCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING )
		}
			
		TryGameModeAnnouncement( player )
	}
	
	ClassicMP_OnIntroFinished()
}

void function InfectionNoIntroSetup()
{
	AddCallback_OnClientConnected( InfectionInitSpawnPlayer )
	AddCallback_GameStateEnter( eGameState.Prematch, InfectionNoIntroStart )
}

// ===============================================================================
//
//
// HARDMODE , 18 October 2023 , edited 30 August 2024
//
//
// ===============================================================================

ClServer_MessageStruct function HardmodeChat(ClServer_MessageStruct message)
{
	string msg = message.message.tolower()

	if (msg.len() == 0 ) // if the message is empty or if there's already infected in the game
		return message

	if (format("%c", msg[0]) == "!") {
		printl("Chat Command Found")
		// command
		msg = msg.slice(1) // remove !

		if (msg == "hardmode")
		{
			message.shouldBlock = true
			entity player = message.player
			if ( player.GetTeam() == INFECTION_TEAM_SURVIVOR && file.hardmode[player] == false && GameTime_TimeLeftSeconds() >= ( 300.0 ) ) {
				GetFuckedLoser( player )
				file.hardmode[player] = true
			} else {
				NSSendInfoMessageToPlayer(player, "NO!!!!!!!")
			}
		}
	}
	return message
}

void function GetFuckedLoser( entity player )
{
	// lower health to 20
	player.SetMaxHealth(25)
	player.SetHealth(25)

	// perma sonared
	/* Highlight_SetEnemyHighlight( player, "enemy_boss_bounty" ) // red sonar just to make it extra spicy
	StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) */

	thread HighlightHardmode( player )

	foreach ( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	player.GiveWeapon( "mp_weapon_semipistol", ["silencer"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE )

	// xd
	Chat_Impersonate( player, "hey infected im the guy with the red glow and i have very low hp because i think this gamemode is too easy", false)
}

void function HighlightHardmode( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	var lastHighlightTime = Time()
	var highlightDuration = 5.0
	var cooldownDuration = 5.0
	array<int> ids = []

	while ( IsAlive(player) )
	{
		WaitFrame()
		vector playerVelV = player.GetVelocity()
		float playerVel = sqrt( playerVelV.x * playerVelV.x + playerVelV.y * playerVelV.y ) // not counting vertical velocity
		float playerVelNormal = playerVel * (0.091392) // metric kph

		// 0 - 45 kph is highlighted
		if ( playerVelNormal < 45 )
		{
			Highlight_SetEnemyHighlight( player, "enemy_boss_bounty" )
			ids.append( StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) )
			lastHighlightTime = Time()
		}
		// 46 - 65 kph is highlighted for 5 seconds every 10 seconds, 
		// once you reach this speed from below 45 kph, you will remain highlighted for 5 seconds before clearing the highlight, then reapplying it after another 5 seconds
		else if ( playerVelNormal >= 45 && playerVelNormal < 66 )
		{
			if ( Time() - lastHighlightTime > cooldownDuration + highlightDuration )
			{
				Highlight_SetEnemyHighlight( player, "enemy_boss_bounty" )
				ids.append( StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) )
				lastHighlightTime = Time()
			}
			else if ( Time() - lastHighlightTime > highlightDuration )
			{
				Highlight_ClearEnemyHighlight( player )
				foreach ( id in ids )
					StatusEffect_Stop( player, id )
			}
		}
		// 66 - 79 kph is highlighted for 5 seconds every 15 seconds
		else if ( playerVelNormal >= 65 && playerVelNormal < 80 )
		{
			if ( Time() - lastHighlightTime > cooldownDuration + highlightDuration + 5.0 )
			{
				Highlight_SetEnemyHighlight( player, "enemy_boss_bounty" )
				ids.append( StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) )
				lastHighlightTime = Time()
			}
			else if ( Time() - lastHighlightTime > highlightDuration)
			{
				Highlight_ClearEnemyHighlight( player )
				foreach ( id in ids )
					StatusEffect_Stop( player, id )
			}
		}
		// 80+ kph is not highlighted
		else
		{
			Highlight_ClearEnemyHighlight( player )
			foreach ( id in ids )
				StatusEffect_Stop( player, id )
		}
	}
}

// ===============================================================================
//
//
// PLAYING CODE
//
//
// ===============================================================================

void function SelectFirstInfected() // ?
{
	thread SelectFirstInfectedDelayed()
}

void function SelectFirstInfectedDelayed()
{
	srand(GetUnixTimestamp()) // don't use the same rng seed each time lol
	wait 5.0
	Chat_ServerBroadcast("Join us on discord at \x1b[36mdiscord.gg/awesometf", true)
	WaitFrame()
	Chat_ServerBroadcast("Please do not go out of bounds.", true)
	wait 5.0 + RandomFloat( 5.0 )
	SetLoadoutGracePeriodEnabled( false )
	WaitFrame()
	ServerCommand("sv_alltalk 1");
	ServerCommand("slide_step_velocity_reduction 10");
	ServerCommand("sv_gravity 750");

	int playerCount = GetPlayerArray().len()
	if (playerCount <= 1)
		return

	if ( file.hasHadFirstInfection ){ // in case a player joins and gets infected before this happens
		array<entity> players = GetPlayerArray()
		array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
		if (players.len() < 8) {
			Chat_ServerBroadcast("Due to a low playercount all survivors are sonared to keep the pace up. Please try not to sweat and make sure everyone has fun.", true)
			foreach ( entity player in survivors ){
				Highlight_SetEnemyHighlight( player, "enemy_sonar" )
				StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) // sonar is better here so the player themselves see the SONAR DETECTED warning.
			}
		}
		return
	}
	array<entity> players = GetPlayerArray()
	int selected = RandomInt( players.len() )
	entity infected = players[ selected ]

	if (file.hardmode[infected] == true) {
		infected = players[ RandomInt( players.len() ) ]
	}

	InfectPlayer( infected, infected )
	RespawnInfected( infected )

	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )

	// they bitched (lmao)

	// // gives a 2nd player a hidden chance to be an impostor sussy baka
	// if ( RandomInt(10) == 0  && GetPlayerArray().len() > 11)
	// {
	// 	printt("doing crazy infection imposter")
	// 	Chat_ServerBroadcast("Silly has been activated. THIS IS A TEMPORARY MESSAGE", true)
	// 	// make sure that the 2nd player isnt also the first infected
	// 	players.remove( selected )
	// 	infected = players[ RandomInt( players.len() ) ]
	// 	thread HiddenInfected( infected )
	// }
	
	if (GetPlayerArray().len() < 8) {
		Chat_ServerBroadcast("Due to a low playercount all survivors are sonared to keep the pace up.", true)
		foreach ( entity player in survivors ){
			Highlight_SetEnemyHighlight( player, "enemy_sonar" )
			StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) // sonar is better here so the player themselves see the SONAR DETECTED warning.
		}
	}
}

// callbacks and misc for 2nd hidden infected
// void function HiddenInfected( entity player )
// {
// 	// callback for player input
// 	AddButtonPressedPlayerInputCallback( player, IN_ATTACK, BecomeInfected )

// 	// Inform the player
// 	NSSendAnnouncementMessageToPlayer( player, "YOU ARE THE HIDDEN INFECTED", "You can turn into an infected on command!", <0,1,0>, 1, 1 )
// 	NSSendInfoMessageToPlayer(player, "Press %%attack%% to turn into an infected!")
// 	HolsterViewModelAndDisableWeapons( player )

// 	// enemy team aka infected see this guy as a blue outline through walls
// 	Highlight_SetEnemyHighlight( player, "fw_friendly" )

// 	foreach( entity infected in GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED ) )
// 	{
// 		// inform the infected team
// 		NSCreateStatusMessageOnPlayer( infected, player.GetPlayerName(), "is the hidden infected!", "banana" )
// 	}

// }

// this function is for a 2nd player to be an impostor
void function BecomeInfected( entity player )
{
	RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, BecomeInfected )
	Highlight_ClearEnemyHighlight( player )
	InfectPlayer( player, player ) // health gets set here

	foreach( entity infected in GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED ) )
	{
		try {
			NSDeleteStatusMessageOnPlayer( infected, "banana" )
		}
		catch ( ex ){
			printt( ex )
		}
	}
	
	// set camo to pond scum
	player.SetSkin( 1 )
	player.SetCamo( 110 )

	// if human, remove helmet bodygroup, human models have some weird bloody white thing underneath their helmet that works well for this, imo
	if ( !player.IsMechanical() )
		player.SetBodygroup( player.FindBodyGroup( "head" ), 1 )

	foreach ( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	if (RandomInt(20) == 1){
		player.GiveWeapon( "mp_weapon_rocket_launcher" )
	} else {
		player.GiveWeapon( "mp_weapon_mgl" )
	}
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE )
	// int specialRoll = RandomInt(99) // this is 0-99 right
	int ordnanceRoll = RandomInt(100)
	player.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_SPECIAL )
	if ( ordnanceRoll <= 9 )
		thread BecomeBoomer( player ) // funny
	else if (ordnanceRoll <= 19){
		player.GiveOffhandWeapon("mp_ability_shifter", OFFHAND_ORDNANCE) // Palomar.PilotPhaseRework
	} else {
		player.GiveOffhandWeapon("mp_ability_heal", OFFHAND_ORDNANCE )
	}

	DeployViewModelAndEnableWeapons( player )
	thread PlayInfectedSounds( player )
}

void function InfectionOnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	if ( victim.GetTeam() == INFECTION_TEAM_SURVIVOR ) // this needs to happen first because of death by OOB
		InfectPlayer( victim, attacker )

	if ( !victim.IsPlayer() || !attacker.IsPlayer() || GetGameState() != eGameState.Playing || !IsValid( attacker ) || !IsValid( victim ) )
		return

	file.killstreak[victim] <- 0

	if ( attacker.IsPlayer() && victim != attacker ) 
	{
		attacker.SetPlayerGameStat( PGS_ASSAULT_SCORE, attacker.GetPlayerGameStat( PGS_ASSAULT_SCORE ) + 1 )
		SetRoundWinningKillReplayAttacker(attacker)


		if ( attacker.GetTeam() == INFECTION_TEAM_SURVIVOR )
		{
			// killstreaks
			file.killstreak[attacker] += 1
			file.deathstreak[victim] += 1
			int kills = file.killstreak[attacker]
			

			// if the killstreak is a multiple of 5 (5, 10, 15, etc), give a random boost
			if ( file.killstreak[attacker] > 4 && ( file.killstreak[attacker] % 5 == 0 ) && MapSettings_SupportsTitans( GetMapName() ) ) // prevents killstreaks on lf and coliseum
			{
				string burncard
				switch ( file.killstreak[attacker] )
				{
					// get a random boost from the array
					case 5:
						burncard = file.lowburnreward[ RandomInt( file.lowburnreward.len() ) ]
						//Chat_ServerBroadcast("\x1b[97m>> \x1b[96m"+attacker+" \x1b[97mis on a \x1b[32mKILLING SPREE "+kills+" \x1b[97m>>")
						//NSSendPopUpMessageToPlayer( attacker, "5 killstreak!" )
						break

					case 10:
						burncard = file.medburnreward[ RandomInt( file.medburnreward.len() ) ]
						//Chat_ServerBroadcast("\x1b[97m>> \x1b[96m"+attacker+" \x1b[97mis \x1b[31mUNSTOPPABLE "+kills+" \x1b[97m>>")
						//NSSendPopUpMessageToPlayer( attacker, "10 killstreak!" )
						break

					default: // after 10 they are all high rewards
						burncard = file.highburnreward[ RandomInt( file.highburnreward.len() ) ]
						//NSSendPopUpMessageToPlayer( attacker, "max killstreak!" )
						break
				}

				if ( file.killstreak[attacker] == 30 )
				{
					if ( !attacker.IsTitan() && SpawnPoints_GetTitan().len() > 0 )
					{
						thread CreateTitanForPlayerAndHotdrop( attacker, GetTitanReplacementPoint( attacker, false ) )
						foreach ( entity player in GetPlayerArray() )
							if ( player != attacker )
								NSSendLargeMessageToPlayer( player, "TITANFALL INCOMING", attacker.GetPlayerName() + " has obtained a titan!", 7, "rui/callsigns/callsign_68_col")
					}
					else 
						BurnMeter_GiveRewardDirect( attacker, burncard )
				}
				else
					BurnMeter_GiveRewardDirect( attacker, burncard )
				NSSendPopUpMessageToPlayer( attacker, file.killstreak[attacker].tostring() + " killstreak!" )
			}
		}
		else // if attacker is infected
		{
			// attacker is infected and got a kill
			file.deathstreak[attacker] <- 0

			if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == eDamageSourceId.human_execution && GetGameState() == eGameState.Playing && attacker.GetTeam() == INFECTION_TEAM_INFECTED ) // 4 March 2024, if died to execution drop gun
			{
				if ( !IsValid( victim ) )
					return
				array<entity> weapons = GetPrimaryWeapons( victim )
				if ( weapons.len() == 0 )
					return
				entity weapon = weapons[0]
				// victim.TakeWeaponNow( weapon.GetWeaponClassName() )
				// vector origin = victim.GetOrigin() + Vector( 0, 0, 100 )
				// vector angles = Vector( 0, 0, 0 )
				// entity newweapon = CreateWeaponEntityByNameWithPhysics( weapon.GetWeaponClassName(), origin, angles )
				attacker.GiveWeapon( weapon.GetWeaponClassName() )
				// newweapon.SetMods( weapon.GetMods() )
				// newweapon.SetWeaponSkin( weapon.GetSkin() )
				// newweapon.SetWeaponCamo( weapon.GetCamo() )
				// if ( weapon.GetProScreenOwner() == victim )
				// {
				// 	newweapon.SetProScreenOwner( victim )
				// 	if ( newweapon.HasMod( "pro_screen" ) )
				// 		UpdateProScreen( victim, newweapon )
				// }
				// newweapon.SetWeaponPrimaryAmmoCount( weapon.GetWeaponPrimaryAmmoCount() )
				// if ( newweapon.GetWeaponPrimaryClipCountMax() > 0 )
				// 	newweapon.SetWeaponPrimaryClipCount( weapon.GetWeaponPrimaryClipCount() )
			}
		}
	}

	// remove boosts from dead players
	//thread PlayerInventory_TakeAllInventoryItems( victim )
	// this appears to not be needed as switching teams removes boosts.
	if ( IsValid( victim.GetPetTitan() ) && victim.GetTeam() == INFECTION_TEAM_SURVIVOR ) // kill any titans if exists
		victim.GetPetTitan().Destroy()
}

void function InfectPlayer( entity player, entity attacker ) {
	SetTeam( player, INFECTION_TEAM_INFECTED )
	player.SetPlayerGameStat( PGS_ASSAULT_SCORE, 0 ) // reset kills
	file.playersToNotifyOfInfection.append( player )
	array<entity> infected = GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED )
	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
	int playerCount = GetPlayerArray().len()
	int infectedCount = GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED ).len()
	int survivorCount = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR ).len()
	float health = ((1-(infectedCount.tofloat()/playerCount.tofloat())) * 200)
	int intHealth = health.tointeger()
	foreach (entity infectedPlayer in infected){
		if (IsAlive( infectedPlayer )){
			if( GetGameState() == eGameState.Postmatch ){
				return
			}  
			if(infectedPlayer.IsTitan()){
				return
			}
			if (infectedCount == 1) { // impossible to win without
				infectedPlayer.SetMaxHealth( 200 )
			}
			else {
				if (infectedCount == playerCount){
					infectedPlayer.SetMaxHealth( 100 )
				} else {
					infectedPlayer.SetMaxHealth( intHealth )
				}
			}
		}
	}
	// check how many survivors there are
	if ( survivors.len() == 0 )
	{
		SetRespawnsEnabled( false )
		SetKillcamsEnabled( false )
		if (attacker.IsPlayer()){
			SetRoundWinningKillReplayAttacker(attacker)
		} else {
			array<entity> infected = GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED )
			SetRoundWinningKillReplayAttacker(infected[0])
		}
		// AddTeamScore( INFECTION_TEAM_INFECTED, 100 ) // for kill replay to work lmao
		SetWinner( INFECTION_TEAM_INFECTED )
	}
	else if ( survivors.len() == 1 && !file.hasHadLastInfection && playerCount > 2 )
		SetLastSurvivor( survivors[ 0 ] )

	if ( !file.hasHadFirstInfection )
	{
		SetLoadoutGracePeriodEnabled( false )
		file.hasHadFirstInfection = true

		foreach ( entity otherPlayer in GetPlayerArray() )
			if ( player != otherPlayer )
				Remote_CallFunction_NonReplay( otherPlayer, "ServerCallback_AnnounceFirstInfected", player.GetEncodedEHandle() )

		PlayMusicToAll( eMusicPieceID.GAMEMODE_1 )
		
		thread CountdownToEvac()
		thread Contingency()
	}
}

void function RespawnInfected( entity player )
{
	if ( player.GetTeam() != INFECTION_TEAM_INFECTED )
		return

	if (file.hardmode[player] == true) {
		file.hardmode[player] = false
	}

	// notify newly infected players of infection
	if ( file.playersToNotifyOfInfection.contains( player ) )
	{
		Remote_CallFunction_NonReplay( player, "ServerCallback_YouAreInfected" )
		file.playersToNotifyOfInfection.remove( file.playersToNotifyOfInfection.find( player ) )
	}

	// set camo to pond scum
	player.SetSkin( 1 )
	player.SetCamo( 110 )

	// if human, remove helmet bodygroup, human models have some weird bloody white thing underneath their helmet that works well for this, imo
	if ( !player.IsMechanical() )
		player.SetBodygroup( player.FindBodyGroup( "head" ), 1 )

	// stats for infected
	//StimPlayer( player, 9999.9 ) // can't do endless since we don't get the visual effect in endless

	// scale health with num of infected
	int playerCount = GetPlayerArray().len()
	int infectedCount = GetPlayerArrayOfTeam( INFECTION_TEAM_INFECTED ).len()
	int survivorCount = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR ).len()
	float health = ((1-(infectedCount.tofloat()/playerCount.tofloat())) * 200)
	int intHealth = health.tointeger()
	if (infectedCount == 1) { // impossible to infect without
		if (file.deathstreak[player] > 4) {
			player.SetMaxHealth( 200 + (file.deathstreak[player] * 10) )
			if (file.deathstreak[player] % 5 == 0) {
				thread DisplayIncreasedHealth( player )
			}
		} else {
			player.SetMaxHealth( 200 )
		}
	}
	else
	{
		if (infectedCount == playerCount) {
			player.SetMaxHealth(100)
		} else { 
			player.SetMaxHealth(intHealth)

			if ( file.deathstreak[player] > 4 && infectedCount < 4 )
				player.SetMaxHealth( intHealth + ( file.deathstreak[player] * 10 ) ) // 10 extra health per death after the 4th death, so they spawn with 50, 60, 70 and so on.
		}
	}

	// set loadout
	foreach ( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	// TEMP: give archer so player so player has a weapon which lets them use offhands
	// need to replace this with a custom empty weapon at some point
	//player.GiveWeapon( "mp_weapon_rocket_launcher" )
	int rocketRoll = RandomInt(20)
	if (rocketRoll == 1){
		player.GiveWeapon( "mp_weapon_rocket_launcher" )
	} else {
		player.GiveWeapon( "mp_weapon_mgl" )
	}
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE )

	// int specialRoll = RandomInt(99) // this is 0-99 right
	int ordnanceRoll = RandomInt(100)
	player.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_SPECIAL )
	if ( ordnanceRoll <= 9 ) {
		thread BecomeBoomer( player ) // funny
	}
	else if (ordnanceRoll <= 19){
		player.GiveOffhandWeapon("mp_ability_shifter", OFFHAND_ORDNANCE) // Palomar.PilotPhaseRework
	}	
	else if (ordnanceRoll <= 29 && playerCount > 7){ // should be 10% chance
		thread BecomeHunter( player )
	}  
	else {
		player.GiveOffhandWeapon("mp_ability_heal", OFFHAND_ORDNANCE )
	}

	thread PlayInfectedSounds( player )
	thread DisplayMutation( player, rocketRoll, ordnanceRoll )
}

void function DisplayMutation( entity player, int rocketRoll, int ordnanceRoll ) { // needs to be threaded cause it needs to be delayed i hate northstar
	wait 1.0
	int playerCount = GetPlayerArray().len()
	if ( !IsValid(player) )
		return
	if ( rocketRoll == 1 && ordnanceRoll > 9 ) {
		NSSendAnnouncementMessageToPlayer( player, "VIRUS MUTATION", "Jumper Variant!", <1,1,0>, 1, 0 )
		wait 3.0
		if ( !IsValid(player) )
			return
	}
	if (ordnanceRoll <= 9 ){
		NSSendAnnouncementMessageToPlayer( player, "VIRUS MUTATION", "Boomer Variant!", <1,0,0>, 1, 0 )
	}
	else if (ordnanceRoll <= 19 ){
		NSSendAnnouncementMessageToPlayer( player, "VIRUS MUTATION", "Phase Variant!", <0,1,0>, 1, 0 )
		// Change enemy highlight color to orange in RGB
		Highlight_SetEnemyHighlightWithParam0( player, "enemy_player", < 0, 255, 0 > )
	}
	else if (ordnanceRoll <= 29 && playerCount > 7 ){
		NSSendAnnouncementMessageToPlayer( player, "VIRUS MUTATION", "Seeker Variant!", <1,0,1>, 1, 0 )
	}
}

void function DisplayIncreasedHealth( entity player )
{
	wait 1.0
	if ( !IsValid(player) )
		return
	NSSendAnnouncementMessageToPlayer( player, "VIRAL RESILIENCE", "Your health has been increased!", <1,1,1>, 1, 0 )
	wait 1.0
	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )

	foreach ( entity survivor in survivors) {
		if ( IsValid(survivor) ) {
			NSSendAnnouncementMessageToPlayer( survivor, "MUTATION DETECTED", "An infected with increased health has been detected!", <1,0,0>, 1, 0 )
		}
	}
}

void function BecomeBoomer( entity player )
{
	player.EndSignal( "OnDeath" )
	// Remove all weapons
	foreach ( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	foreach ( entity weapon in player.GetOffhandWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )

	if ( RandomInt(100) <= 9 ) { // give phase
		player.GiveOffhandWeapon("mp_ability_shifter_super", OFFHAND_SPECIAL ) // toggle phase shift, side effect is that you slowly grow blind while in the phase dimension
		array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
		//wait 3.0 // wait 3 seconds to hopefully give enough time for the first survivor display to go away
		foreach ( entity survivor in survivors) {
			NSSendAnnouncementMessageToPlayer( survivor, "MUTATION DETECTED", "A phase boomer has spawned!", <1,0,0>, 1, 0 )
		}
	}
	else
		player.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_SPECIAL )

	// required to allow boomer to use offhands, they explode anyways if they try to use melee
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, [ "allow_as_primary" ])
	player.SetActiveWeaponByName( "melee_pilot_emptyhanded" )

	// health no longer nerfed
	//player.SetMaxHealth( player.GetMaxHealth() )
	//player.SetHealth( player.GetMaxHealth() )

	// Change enemy highlight color to orange in RGB
	Highlight_SetEnemyHighlightWithParam0( player, "enemy_player", < 255, 165, 0 > )

	// Give amped battery trail FX
	int attachID = player.LookupAttachment( "CHESTFOCUS" )
	int friendlyTeam = player.GetTeam()
	entity boomerFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( BATTERY_FX_AMPED) , FX_PATTACH_POINT_FOLLOW, attachID )
	SetTeam( boomerFX, friendlyTeam )
	boomerFX.SetOwner( player )
	boomerFX.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // visible except owner

	// callback for player input
	AddButtonPressedPlayerInputCallback( player, IN_ATTACK, BoomerAttack )
	AddButtonPressedPlayerInputCallback( player, IN_MELEE, BoomerAttack )
	// AddButtonPressedPlayerInputCallback( player, IN_OFFHAND1, PhaseExplode )

	OnThreadEnd(
	function() : ( player, boomerFX )
		{
			RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, BoomerAttack )
			RemoveButtonPressedPlayerInputCallback( player, IN_MELEE, BoomerAttack )
			// RemoveButtonPressedPlayerInputCallback( player, IN_OFFHAND1, PhaseExplode )
			if ( IsValid( boomerFX ) )
				boomerFX.Destroy()
		}
	)

	// Inform the player
	NSSendInfoMessageToPlayer(player, "Press %%attack%% to explode!")

	WaitSignal( player, "StartPhaseShift" ) // replacement for WaitForever, would only get triggered if the player has phase shift and activated it.
	RemoveButtonPressedPlayerInputCallback( player, IN_ATTACK, BoomerAttack )
	RemoveButtonPressedPlayerInputCallback( player, IN_MELEE, BoomerAttack )
	thread PhaseExplodeThreaded( player )
}

void function PhaseExplodeThreaded( entity player )
{
	WaitSignal( player, "StopPhaseShift" )
	BoomerAttack( player )
}

void function BoomerAttack( entity player )
{

	// create an explosion at the player's location
	PlayFX( $"P_impact_exp_FRAG_metal", player.GetOrigin(), < -90.0, 0.0, 0.0 > )
	EmitSoundOnEntityExceptToPlayer( player, player, "explo_fraggrenade_impact_3p" )
	EmitSoundAtPositionOnlyToPlayer( TEAM_UNASSIGNED, player.GetOrigin(), player, "explo_fraggrenade_impact_1p" )
	RadiusDamage(
		player.EyePosition(),												// origin
		player,												// owner
		player,		 									// inflictor
		200,							// pilot damage
		2500,									// heavy armor damage aka titans :)
		5,					// inner radius
		320,					// outer radius
		SF_ENVEXPLOSION_NO_NPC_SOUND_EVENT,					// explosion flags
		0, 													// distanceFromAttacker
		0, 													// explosionForce
		DF_EXPLOSION | DF_GIB,										// damage flags
		eDamageSourceId.funnyboomer		// damage source id
	)
}

void function BecomeHunter( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	// Remove all weapons
	// foreach ( entity weapon in player.GetMainWeapons() )
	// 	player.TakeWeaponNow( weapon.GetWeaponClassName() )

	// foreach ( entity weapon in player.GetOffhandWeapons() )
	// 	player.TakeWeaponNow( weapon.GetWeaponClassName() )

	// player.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_SPECIAL )

	// player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, [ "allow_as_primary" ])
	// player.SetActiveWeaponByName( "melee_pilot_emptyhanded" )

	// every 10 second, emit a sonar pulse
	player.GiveOffhandWeapon("mp_ability_heal", OFFHAND_ORDNANCE )
	while (true)
	{
		wait 10.0
		PlayFX( $"exp_sonar_pulse", player.GetOrigin(), < -90.0, 0.0, 0.0 > )
		PulseLocation( player, player.GetTeam(), player.GetOrigin(), false, false )
		EmitSoundAtPositionExceptToPlayer( TEAM_UNASSIGNED, player.GetOrigin(), player, "Titan_Tone_SonarLock_Impact_Pulse_3P" )
		EmitSoundAtPositionOnlyToPlayer( TEAM_UNASSIGNED, player.GetOrigin(), player, "Titan_Tone_SonarLock_Impact_Pulse_1P" )

		// sonar the player too
		//StatusEffect_AddTimed( player, eStatusEffect.sonar_detected, 1.0, 5.0, 0.0 )
	}
}

void function CountdownToEvac()
{
	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
	wait 10.0
	while ( true )
	{
		survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )

		// if time remaining is 25% of original time limit
		//GameMode_GetTimeLimit( GameRules_GetGameMode() ) * 60 ) / 100 * 25
		if ( ( GameTime_TimeLeftSeconds() <= ( ( 60.0 ) ) ) ) // better to do flat 60 seconds, easier to understand and make rates for
		{
			float EVAC_WAIT_TIME, EVAC_ARRIVAL_TIME, EVAC_INITIAL_WAIT
			//GameTime_TimeLeftSeconds().tofloat() / 2
			EVAC_INITIAL_WAIT = 0.0
			EVAC_ARRIVAL_TIME = 30 // 50%
			EVAC_WAIT_TIME = 15.0

			thread SurvivorEvac( INFECTION_TEAM_SURVIVOR, EVAC_INITIAL_WAIT, EVAC_ARRIVAL_TIME, EVAC_WAIT_TIME, CanPlayerBoardEvac, EvacEpilogueShouldLeaveEarly, EvacEpilogueCompleted )
			return
		}

		wait 1.0
	}
}

void function Contingency() // ensure shitters are still infected if evac dies
{
	while (true)
	{
		if (file.evacDead)
		{
			if ( ( GameTime_TimeLeftSeconds() <= ( ( 5.0 ) ) ) )
			{
				array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )

				foreach ( entity player in survivors)
					InfectPlayer( player, player )
			}
		}
		wait 1.0
	}
}

void function TestEvac() // mostly deprecated
{
	thread SurvivorEvac( INFECTION_TEAM_SURVIVOR, 1.0, 20.0, 20.0, CanPlayerBoardEvac, EvacEpilogueShouldLeaveEarly, EvacEpilogueCompleted )
}

void function NoInfect() // used for events in-game
{
	file.hasHadFirstInfection = true
}

void function PlayInfectedSounds( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	float nextRandomSound
	while ( true )
	{
		WaitFrame()

		int meleeState = player.PlayerMelee_GetState()
		if ( nextRandomSound < Time() || meleeState != 0 )
		{
			string selectedSound
			if ( CoinFlip() )
				selectedSound = "prowler_vocal_attack"
			else
				selectedSound = "prowler_vocal_attackmiss"

			bool canSeeSurvivor
			foreach ( entity survivor in GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR ) )
				if ( TraceLineSimple( player.GetOrigin(), survivor.GetOrigin(), survivor ) == 1.0 )
					canSeeSurvivor = true

			// _int sounds are less agressive so only play them if we aren't in some sorta fight
			if ( player.GetHealth() == player.GetMaxHealth() || !canSeeSurvivor || meleeState != 0 )
				selectedSound += "_int"

			EmitSoundOnEntity( player, selectedSound )

			nextRandomSound = Time() + max( 2.5, RandomFloat( 12.0 ) )
			while ( player.PlayerMelee_GetState() != 0 ) // need to ensure this is updated
				WaitFrame()
		}
	}
}

void function setTime( float time )
{
	SetServerVar( "gameEndTime", Time() + time )
}

void function SetLastSurvivor( entity player )
{
	int playerCount = GetPlayerArray().len()
	foreach ( entity otherPlayer in GetPlayerArray() )
		Remote_CallFunction_NonReplay( otherPlayer, "ServerCallback_AnnounceLastSurvivor", player.GetEncodedEHandle() )

	if (GameTime_TimeLeftSeconds() > 45 || playerCount > 2)
		Highlight_SetEnemyHighlight( player, "enemy_sonar" )
		StatusEffect_AddEndless( player, eStatusEffect.sonar_detected, 1.0 ) // sonar is better here so the player themselves see the SONAR DETECTED warning.
	if ( (SpawnPoints_GetTitan().len() > 0) && (GameTime_TimeLeftSeconds() > 45) && !file.evacCame && (playerCount > 7)) {
		thread CreateTitanForPlayerAndHotdrop( player, GetTitanReplacementPoint( player, false ) )
	}
	if ( GameTime_TimeLeftSeconds() > 45 && playerCount > 7 && !file.evacCame )
	{
		SetServerVar( "gameEndTime", Time() + 45.0 )
		PlayMusicToAll( eMusicPieceID.LEVEL_LAST_MINUTE )
	}

	file.hasHadLastInfection = true

	if ( IsValid( GetEnt("npc_dropship") ) ) // don't want to spawn another dropship lol
		return
	
	//float EVAC_WAIT_TIME, EVAC_ARRIVAL_TIME, EVAC_INITIAL_WAIT

	//EVAC_INITIAL_WAIT = 0.0
	//EVAC_ARRIVAL_TIME = GameTime_TimeLeftSeconds().tofloat() / 2 // 50%
	//EVAC_WAIT_TIME = 10.0

	//thread SurvivorEvac( INFECTION_TEAM_SURVIVOR, EVAC_INITIAL_WAIT, EVAC_ARRIVAL_TIME, EVAC_WAIT_TIME, CanPlayerBoardEvac, EvacEpilogueShouldLeaveEarly, EvacEpilogueCompleted )
}

int function TimeoutCheckSurvivors()
{
	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
	if ( survivors.len() > 0 )
	{
		SetRespawnsEnabled( false )
		SetKillcamsEnabled( false )
		SetRoundWinningKillReplayAttacker(survivors[ 0 ])
		// AddTeamScore( INFECTION_TEAM_SURVIVOR, 100 ) // for kill replay to work lmao
		return INFECTION_TEAM_SURVIVOR
	}
	return INFECTION_TEAM_INFECTED
}

bool function InfectionShouldPlayerStartBleedout( entity player, var damageInfo )
{
	return player.GetTeam() != INFECTION_TEAM_INFECTED
}

void function OnWinnerDetermined()
{
	SetRespawnsEnabled( false )
	SetKillcamsEnabled( false ) // apparently does not affect final killcam
	if (RandomInt(10) == 1) {
		Chat_ServerBroadcast("gg", true)
	}
	thread OnWinnerDetermined_Threaded()

}

void function OnWinnerDetermined_Threaded()
{
	wait 5.0
	if (GetPlayerArray().len() > 3) {
		foreach (entity player in GetPlayerArray()) {
			if ( IsValid(player) ) { // this crashed due to someone leaving once. now isvalid will be here to stay forever. lol.
				if (file.moved[player] == false) {
					NSDisconnectPlayer( player, "You've been kicked for being AFK for an entire round." )
				}
			}
		}
	}
}

// ============================================================================================================================================
// 
//
//
// EVAC CODE !!!
//
//
//
// ============================================================================================================================================

void function EvacSpectatorFunc( entity player )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )
	file.evacDropship.EndSignal( "OnDestroy" )
	
	entity cam = GetEnt( expect string( file.currentEvacNode.kv.target ) )
	if ( !IsValid( cam ) )
		return
	
	player.SetObserverModeStaticPosition( cam.GetOrigin() )
	player.SetObserverModeStaticAngles( cam.GetAngles() )
	player.StartObserverMode( OBS_MODE_STATIC )
	
	file.evacDropship.WaitSignal( "EvacOver" )
}

void function SurvivorEvac( int evacTeam, float initialWait, float arrivalTime, float waitTime, bool functionref( entity, entity ) canBoardCallback, bool functionref( entity ) shouldLeaveEarlyCallback, void functionref( entity ) completionCallback, entity customEvacNode = null )
{

	
	if (GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR ).len() == 1)
		if (GetPlayerArray().len() != 1)
			return
	file.evacCame = true
	svGlobal.levelEnt.Signal( "ResetEvac" )
	wait 0.1
	svGlobal.levelEnt.EndSignal( "ResetEvac" )

	EvacShipSetting evacShip = GetEvacShipSettingByTeam( evacTeam )
	
	wait initialWait 

	// setup evac nodes if not manually registered
	if ( file.evacNodes.len() == 0 && !IsValid( customEvacNode ) )
	{
		for ( int i = 1; ; i++ )
		{
			entity newNode = GetEnt( "escape_node" + i )
			if ( !IsValid( newNode ) )
				break
			
			file.evacNodes.append( newNode )
		}
	}
	
	// setup space node if not manually registered
	if ( !IsValid( file.spaceNode ) )
		file.spaceNode = GetEnt( "spaceNode" )

	entity evacNode = customEvacNode
	if ( !IsValid( customEvacNode ) )
		evacNode = file.evacNodes.getrandom()
		
	file.currentEvacNode = evacNode

	// setup client evac position
	file.evacIcon = CreateEntity( "info_target" )
	file.evacIcon.SetOrigin( evacNode.GetOrigin() )
	file.evacIcon.kv.spawnFlags = SF_INFOTARGET_ALWAYS_TRANSMIT_TO_CLIENT
	DispatchSpawn( file.evacIcon )
	file.evacIcon.DisableHibernation()

	int index = GetParticleSystemIndex( FX_EVAC_MARKER )

	entity effectFriendly = StartParticleEffectInWorld_ReturnEntity( index, evacNode.GetOrigin(), < 0,0,0 > )
	SetTeam( effectFriendly, evacTeam )
	effectFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY

	wait 0.5 // need to wait here, or the target won't appear on clients for some reason
	// eta until arrive
	SetTeamActiveObjective( evacTeam, "EG_DropshipExtract", Time() + arrivalTime, file.evacIcon )
	SetTeamActiveObjective( GetOtherTeam( evacTeam ), "EG_StopExtract", Time() + arrivalTime, file.evacIcon )
	
	// would've liked to use cd_dropship_rescue_side_start length here, but can't since this is done before dropship spawn, can't
	wait arrivalTime - 4.33333

	entity dropship = CreateDropship( evacTeam, evacNode.GetOrigin(), evacNode.GetAngles() )

	thread DropShipTempHide( dropship ) // prevent showing model and health bar on spawn

	// nessie rework
	//dropship.SetModel( $"models/vehicle/crow_dropship/crow_dropship_hero.mdl" ) 
	//dropship.SetValueForModelKey( $"models/vehicle/crow_dropship/crow_dropship_hero.mdl" )
	dropship.SetModel( evacShip.shipModel )
	dropship.SetValueForModelKey( evacShip.shipModel )
	// rework end
	dropship.SetMaxHealth( EVAC_SHIP_HEALTH )
	dropship.SetHealth( EVAC_SHIP_HEALTH )
	dropship.SetShieldHealth( EVAC_SHIP_SHIELDS )
	SetTargetName( dropship, "#NPC_EVAC_DROPSHIP" )
	DispatchSpawn( dropship )
	// reduce nuclear core's damage
	AddEntityCallback_OnDamaged( dropship, EvacDropshipDamaged )
    AddEntityCallback_OnKilled( dropship, EvacDropshipKilled )
	
	dropship.s.evacSlots <- [ null, null, null, null, null, null, null, null ]
	file.evacDropship = dropship
	
	dropship.EndSignal( "OnDestroy" )
	OnThreadEnd( function() : ( evacTeam, completionCallback, dropship ) 
	{
		if ( "evacTrigger" in dropship.s )
			dropship.s.evacTrigger.Destroy()
		
		// this should be for both teams
		if( !IsValid( dropship ) )
		{
			SetTeamActiveObjective( evacTeam, "EG_DropshipExtractDropshipDestroyed" )
			SetTeamActiveObjective( GetOtherTeam( evacTeam ), "EG_DropshipExtractDropshipDestroyed" )
			
			foreach( entity player in GetPlayerArrayOfTeam( evacTeam ) )
				SetPlayerChallengeEvacState( player, 0 )
		}
	
		foreach ( entity player in dropship.s.evacSlots )
		{
			if ( !IsValid( player ) )
				continue
			
			player.ClearInvulnerable()
		}
		
		// this is called whether dropship is destroyed or evac finishes, callback can handle this itself
		thread completionCallback( dropship )
	})
	
	// flyin
	Spectator_SetCustomSpectatorFunc( EvacSpectatorFunc )
	thread PlayAnim( dropship, "cd_dropship_rescue_side_start", evacNode )

	// fly in sound and effect
	EmitSoundOnEntity( dropship, evacShip.flyinSound )
	thread WarpInEffectEvacShip( dropship )
	
	// calculate time until idle start
	float sequenceDuration = dropship.GetSequenceDuration( "cd_dropship_rescue_side_start" )
	float cycleFrac = dropship.GetScriptedAnimEventCycleFrac( "cd_dropship_rescue_side_start", "ReadyToLoad" )
	wait sequenceDuration * cycleFrac
	
	thread PlayAnim( dropship, "cd_dropship_rescue_side_idle", evacNode )

	// hover sound
	EmitSoundOnEntity( dropship, evacShip.hoverSound )
	
	// eta until leave
	SetTeamActiveObjective( evacTeam, "EG_DropshipExtract2", Time() + waitTime, file.evacIcon )
	SetTeamActiveObjective( GetOtherTeam( evacTeam ), "EG_StopExtract2", Time() + waitTime, file.evacIcon )	

	// dialogue
	PlayFactionDialogueToTeam( "mp_evacGo", evacTeam )
	PlayFactionDialogueToTeam( "mp_evacStop", GetOtherTeam( evacTeam ) )

	// stop evac beam
	if( IsValid( effectFriendly ) )
		EffectStop( effectFriendly )
	
	// setup evac trigger
	entity trigger = CreateEntity( "trigger_cylinder" )
	// increased from default
	trigger.SetRadius( 250 )
	trigger.SetAboveHeight( 150 )
	trigger.SetBelowHeight( 150 )
	trigger.SetOrigin( dropship.GetOrigin() )
	trigger.SetParent( dropship, "ORIGIN" )
	DispatchSpawn( trigger )
	// have to do this inline since we capture the completionCallback
	trigger.SetEnterCallback( void function( entity trigger, entity player ) : ( canBoardCallback, dropship ) 
	{ 	
		if ( !player.IsPlayer() || !IsAlive( player ) || player.IsTitan() || player.ContextAction_IsBusy() || !canBoardCallback( dropship, player ) || PlayerInDropship( player, dropship ) )
			return
		
		thread AddPlayerToEvacDropship( dropship, player )
	})
	
	dropship.s.evacTrigger <- trigger
		
	float waitStartTime = Time()
	while ( Time() - waitStartTime < waitTime )
	{
		if ( shouldLeaveEarlyCallback( dropship ) )
			break
			
		WaitFrame()
	}

	// fly out sound
	StopSoundOnEntity( dropship, evacShip.hoverSound )
	EmitSoundOnEntity( dropship, evacShip.flyoutSound )
	
	// holster all weapons
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			player.HolsterWeapon()
	
	// fly away
	dropship.Signal( "EvacShipLeaves" )
	thread PlayAnim( dropship, "cd_dropship_rescue_side_end", evacNode )
	
	SetTeamActiveObjective( evacTeam, "EG_DropshipExtractDropshipFlyingAway" )
	SetTeamActiveObjective( GetOtherTeam( evacTeam ), "EG_StopExtractDropshipFlyingAway" )
	
	EmitSoundOnEntity(dropship, "crow_evac_warpflyout_6ch_v2_03")
	wait dropship.GetSequenceDuration( "cd_dropship_rescue_side_end" ) - WARPINFXTIME
	
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			Remote_CallFunction_NonReplay( player, "ServerCallback_PlayScreenFXWarpJump" )
	
	wait WARPINFXTIME

	dropship.kv.VisibilityFlags = 0 // prevent jetpack trails being like "dive" into ground
	WaitFrame() // better wait because we are server
	if( !IsValid( dropship ) )
		return
	thread __WarpOutEffectShared( dropship )
	
	// go to space 
	
	// hardcoded angles here are a hack, spacenode position doesn't face the planet in the skybox, for some reason
	// nvm removing for now
	//file.spaceNode.SetAngles( < 30, -75, 20 > )
	
	dropship.SetOrigin( file.spaceNode.GetOrigin() )
	dropship.SetAngles( file.spaceNode.GetAngles() )
	dropship.SetInvulnerable()
	dropship.Signal( "EvacOver" )
	thread PlayAnim( dropship, "ds_space_flyby_dropshipA", file.spaceNode )
	
	foreach( entity player in GetPlayerArray() )
	{	
		// evac-ed players only beyond this point
		if ( !PlayerInDropship( player, dropship ) )
		{
			if ( player.GetTeam() == dropship.GetTeam() )
			{
				SetPlayerActiveObjective( player, "EG_DropshipExtractFailedEscape" )
				SetPlayerChallengeEvacState( player, 2 )
			}
				
			continue
		}
		
		SetPlayerActiveObjective( player, "EG_DropshipExtractSuccessfulEscape" )

		dropship.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
		
		// skybox
		player.SetSkyCamera( GetEnt( SKYBOXSPACE ) )
		Remote_CallFunction_NonReplay( player, "ServerCallback_DisableHudForEvac" )
		Remote_CallFunction_NonReplay( player, "ServerCallback_SetClassicSkyScale", dropship.GetEncodedEHandle(), 0.7 )
		Remote_CallFunction_NonReplay( player, "ServerCallback_SetMapSettings", 4.0, false, 0.4, 0.125 )
		SetPlayerChallengeEvacState( player, 1 )		
		// display player [Evacuated] in killfeed
		foreach ( entity otherPlayer in GetPlayerArray() )
			Remote_CallFunction_NonReplay( otherPlayer, "ServerCallback_EvacObit", player.GetEncodedEHandle() )
	}

	// award player score to evacing team
	int evacCount = 0
	array<entity> evacingPlayers = GetPlayerArrayOfTeam( dropship.GetTeam() ) // all players that are supposed to evac in the dropship

	// count how many players are in the dropship
	foreach ( entity player in evacingPlayers )
	{
		if ( !PlayerInDropship( player, dropship ) )
			continue
		
		evacCount++
	}

	bool allEvac = evacCount == evacingPlayers.len()

	foreach(entity player in evacingPlayers)
	{
		if ( !PlayerInDropship( player, dropship ) )
			continue

		AddPlayerScore( player, "HotZoneExtract" )
		UpdatePlayerStat( player, "misc_stats", "evacsSurvived" )

		if ( allEvac )
			AddPlayerScore( player, "TeamBonusFullEvac" )
	}

	// sole survivor (but not the only one on the team)
	if ( evacCount == 1 && !allEvac )
	{
		// we can assume there is one player in the array because otherwise evacCount wouldn't be 1
		AddPlayerScore( evacingPlayers[0], "SoleSurvivor" )
	}
}

void function AddPlayerToEvacDropship( entity dropship, entity player ) 
{
	int slot = RandomInt( dropship.s.evacSlots.len() )
	for ( int i = 0; i < dropship.s.evacSlots.len(); i++ )
	{
		if ( !IsValid( dropship.s.evacSlots[ slot ] ) )
		{
			dropship.s.evacSlots[ slot ] = player
			break
		}
	
		slot = ( slot + 1 ) % expect int( dropship.s.evacSlots.len() )
	}
	
	// no slots available
	if ( !PlayerInDropship( player, dropship ) )
		return

	UpdatePlayerStat( player, "misc_stats", "evacsAttempted" )

	// need to cancel if the dropship dies
	dropship.EndSignal( "OnDeath", "OnDestroy" )

	player.SetInvulnerable()
	player.UnforceCrouch()
	player.ForceStand()

	FirstPersonSequenceStruct fp
	//fp.firstPersonAnim = EVAC_EMBARK_ANIMS_1P[ slot ]
	fp.thirdPersonAnim = EVAC_EMBARK_ANIMS_3P[ slot ]
	fp.attachment = "RESCUE"
	fp.teleport = true
	fp.thirdPersonCameraAttachments = [ "VDU" ] // this seems wrong, firstperson anim has better angles, but no head
	
	EmitSoundOnEntityOnlyToPlayer( player, player, SHIFTER_START_SOUND_3P )
	// should play SHIFTER_START_SOUND_1P when they actually arrive in the ship i think, unsure how this is supposed to be done
	PlayPhaseShiftDisappearFX( player )
	FirstPersonSequence( fp, player, dropship )
	
	FirstPersonSequenceStruct idleFp
	idleFp.firstPersonAnimIdle = EVAC_IDLE_ANIMS_1P[ slot ]
	idleFp.thirdPersonAnimIdle = EVAC_IDLE_ANIMS_3P[ slot ]
	idleFp.attachment = "RESCUE"
	idleFp.teleport = true
	idleFp.hideProxy = true
	idleFp.viewConeFunction = ViewConeWide  
		
	thread FirstPersonSequence( idleFp, player, dropship )
	ViewConeWide( player ) // gotta do this after for some reason, adding it to idleFp does not work for some reason
}

bool function PlayerInDropship( entity player, entity dropship )
{
	// couldn't get "player in dropship.s.evacSlots" to work for some reason, likely due to static typing?
	foreach ( entity dropshipPlayer in dropship.s.evacSlots )
		if ( dropshipPlayer == player )
			return true
			
	return false
}

void function EvacDropshipKilled( entity dropship, var damageInfo )
{
	file.evacDead = true
	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
	foreach ( entity player in dropship.s.evacSlots )
	{
		if ( IsValid( player ) && IsAlive( player ) )
		{
			player.ClearParent()
			player.Die( DamageInfo_GetAttacker( damageInfo ), DamageInfo_GetWeapon( damageInfo ), { damageSourceId = eDamageSourceId.evac_dropship_explosion, scriptType = DF_GIB } )
		}
	}
}

bool function CanPlayerBoardEvac( entity dropship, entity player )
{
	// can't board a dropship on a different team
	if ( dropship.GetTeam() != player.GetTeam() )
		return false
	
	// check if there are any free slots on the dropship, if there are then they can board
	foreach ( entity player in dropship.s.evacSlots )
		if ( !IsValid( player ) )
			return true
	
	// no empty slots
	return false
}

bool function EvacEpilogueShouldLeaveEarly( entity dropship )
{
	int numEvacing
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			numEvacing++

	return GetPlayerArrayOfTeam_Alive( dropship.GetTeam() ).len() == numEvacing || numEvacing == dropship.s.evacSlots.len()
}

void function EvacEpilogueCompleted( entity dropship )
{
	wait 3.0
	
	if( !IsValid(dropship) && !IsAlive(dropship) )
		return

	array<entity> survivors = GetPlayerArrayOfTeam( INFECTION_TEAM_SURVIVOR )
	int numEvacing = 0
	foreach ( entity player in survivors)
		if ( !PlayerInDropship( player, dropship ) )
			InfectPlayer( player, player )
	wait 3.0
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			numEvacing++

	if ( numEvacing != 0 )
		SetWinner(INFECTION_TEAM_SURVIVOR)
	else
		SetWinner(INFECTION_TEAM_INFECTED)

	foreach ( entity player in GetPlayerArray() )
		ScreenFadeToBlackForever( player, 2.0 )
}

// nessie functions
void function CheckIfAnyPlayerLeft( int evacTeam )
{
	wait GAME_EPILOGUE_PLAYER_RESPAWN_LEEWAY
	float startTime = Time()

	OnThreadEnd(
		function() : ( evacTeam )
		{
			SetTeamActiveObjective( evacTeam, "EG_DropshipExtractEvacPlayersKilled" )
			SetTeamActiveObjective( GetOtherTeam( evacTeam ), "EG_StopExtractEvacPlayersKilled" )
			thread EvacEpilogueCompleted( null )
            // score for killing the entire evacing team
			foreach ( entity player in GetPlayerArray() )
			{
				if ( player.GetTeam() == evacTeam )
					continue

				AddPlayerScore( player, "TeamBonusKilledAll")
			}
		}
	)
	while( true )
	{
		if( GetPlayerArrayOfTeam_Alive( evacTeam ).len() == 0 )
			break
		if( GetGameState() == eGameState.Postmatch )
			return
		WaitFrame()
	}	
}

void function DropShipTempHide( entity dropship )
{
	dropship.kv.VisibilityFlags = 0 // or it will still shows the jetpack fxs
	HideName( dropship )
	wait 0.46
	if( IsValid( dropship ) )
	{
		dropship.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
		ShowName( dropship )
	}
}

EvacShipSetting function GetEvacShipSettingByTeam( int team )
{
	EvacShipSetting tempSetting
	if( team == TEAM_IMC )
	{
		tempSetting.shipModel = $"models/vehicle/goblin_dropship/goblin_dropship_hero.mdl"
		tempSetting.flyinSound = "Goblin_IMC_Evac_Flyin"
		tempSetting.hoverSound = "Goblin_IMC_Evac_Hover"
		tempSetting.flyoutSound = "Goblin_IMC_Evac_FlyOut"
	}
	if( team == TEAM_MILITIA )
	{
		tempSetting.shipModel = $"models/vehicle/crow_dropship/crow_dropship_hero.mdl"
		tempSetting.flyinSound = "Crow_MCOR_Evac_Flyin"
		tempSetting.hoverSound = "Crow_MCOR_Evac_Hover"
		tempSetting.flyoutSound = "Crow_MCOR_Evac_Flyout"
	}
	return tempSetting
}

void function EvacDropshipDamaged( entity evacShip, var damageInfo )
{
	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	if( damageSourceID == damagedef_nuclear_core )
		DamageInfo_SetDamage( damageInfo, DamageInfo_GetDamage( damageInfo )/3 )
}

void function WarpInEffectEvacShip( entity dropship )
{
    dropship.EndSignal( "OnDestroy" )
	float sfxWait = 0.1
	float totalTime = WARPINFXTIME
	float preWaitTime = 0.16 // give it some time so it's actually playing anim, and we can get it's "origin" attatch
	string sfx = "dropship_warpin"

	wait preWaitTime

	int attach = dropship.LookupAttachment( "origin" )
	vector origin = dropship.GetAttachmentOrigin( attach )
	vector angles = dropship.GetAttachmentAngles( attach )

	entity fx = PlayFX( FX_GUNSHIP_CRASH_EXPLOSION_ENTRANCE, origin, angles )
	fx.FXEnableRenderAlways()
	fx.DisableHibernation()

	wait sfxWait
	EmitSoundAtPosition( TEAM_UNASSIGNED, origin, sfx )

	wait totalTime - sfxWait
}